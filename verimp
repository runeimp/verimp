#!/usr/bin/env bash
###################
# VerImp
#
# SemVer (Semantic Versioning) number handling script that can compare common package manager syntax.
# In other words; it supports the syntax used by npm/Bower. Full support for bundler, etc. to come at a later date.
#
# @see [Semantic Versioning]: http://semver.org/
# @see [Semantic versioning and npm | npm Documentation]: https://docs.npmjs.com/getting-started/semantic-versioning
# @see [sindresorhus/semver-regex: Regular expression for matching semver versions]: https://github.com/sindresorhus/semver-regex
#
#####
# Exit Codes:
# -----------
# 0 = The versions are compatible
# 1 = The versions are not compatible
# 2 = Invalid arguments
#
#####
# ChangeLog:
# ----------
# 2016-05-11  0.1.0      Finally realized the better way.
# 2016-05-10  0.0.2      Radical logic changes.
# 2016-05-10  0.0.1      Initial script creation.
#
#

APP_AUTHOR_NAME="RuneImp"
APP_AUTHOR_MAIL="runeimp@gmail.com"
APP_NAME="VerImp"
APP_FILE="verimp"
APP_VERSION="0.1.0"
APP_LICENSES="http://opensource.org/licenses/MIT"
APP_LABEL="${APP_AUTHOR_NAME}'s $APP_NAME v$APP_VERSION
License(s): $APP_LICENSES"


#
# CONSTANTS (theoretical)
#

# SemVer MMP (Major.Minor.Patch) RegEx
SEMVER_MMP_RE='(([0-9]+)?(\.([0-9]+))?(\.([0-9]+))?)' # RegEx Positions: 1=MMP, 2=Major, 3=Minor, 4=Patch

# SemVer 1.0.0 RegEx with Range Indicator or Version Denotation prefix
SEMVER_1_RE='(^[xXvV~*^]|^)?([0-9xX*]*)(\.([0-9xX*]+))?(\.(xX*|[0-9]+))?(-([^+]*))?([+](.*))?'

# SemVer 2.0.0 RegEx with Range Indicator or Version Denotation prefix
SEMVER_2_RE='(^[vV~^]|^)?([xX*]|[0-9]+)?(\.([xX*]|[0-9]+))?(\.([xX*]|[0-9]+))?([-]([0-9a-zA-Z-]+))?([+](.+))?'

# SEMVER_2_RE with permissive Prerelease delimiter
SEMVER_NORMALIZE_RE='(^[vV~^]|^)?([xX*]|[0-9]+)?(\.([xX*]|[0-9]+))?(\.([xX*]|[0-9]+))?([^+]([0-9a-zA-Z-]+))?([+](.+))?'

# SEMVER_2_RE with permissive tagging
SEMVER_ALL_TAGS_RE='(^[vV~^]|^)?([xX*]|[0-9]+)?(\.([xX*]|[0-9]+))?(\.([xX*]|[0-9]+))?([^+]([^+]+)(\+(.+))?)?'

ONE_OR_TWO_POSITION_VER_RE='^[0-9]+(\.[0-9]+)?$'


#
# VARIABLES
#


#
# FUNCTIONS
#


semver_clean_args()
{
	local clean=''
	local -i major
	local -i minor
	local -i patch

	[[ "$1" = '*' ]] && major=0 || major="$1"
	[[ "$2" = '*' ]] && minor=0 || minor="$2"
	[[ "$3" = '*' ]] && patch=0 || patch="$3"
	clean="${major}.${minor}.${patch}"

	# echo "semver_clean_args() | \$clean: $clean" 1>&2
	printf '%s' "$clean"
}


semver_clean_re()
{
	local clean=''
	local -i major
	local -i minor
	local -i patch
	local temp=''

	if [[ "$1" =~ $SEMVER_MMP_RE ]]; then
		# local len=${#BASH_REMATCH[@]}
		# let "len -= 1"
		# for i in $(seq 1 $len); do
		# 	verimp_error "semver_clean_re() | \${BASH_REMATCH[$i]}: '${BASH_REMATCH[$i]}'"
		# done
		
		temp="${BASH_REMATCH[1]}"
		[[ "x${temp}x" != 'xx' ]] && clean=$temp || clean=0.0.0
		temp="${BASH_REMATCH[2]}"
		[[ "x${temp}x" != 'xx' ]] && major=$temp || major=0
		temp="${BASH_REMATCH[4]}"
		[[ "x${temp}x" != 'xx' ]] && minor=$temp || minor=0
		temp="${BASH_REMATCH[6]}"
		[[ "x${temp}x" != 'xx' ]] && patch=$temp || patch=0

		[[ "$clean" == '0.0.0' ]] && clean="${major}.${minor}.${patch}"
		# verimp_error "semver_clean_re() | MMP: '${major}.${minor}.${patch}' | clean: $clean"
	fi

	printf '%s' "$clean"
}


semver_normalize_x()
{
	local result="$1"

	case "$1" in
		[X*] | '')	result='x'	;;
	esac
	# verimp_error "$(printf "semver_normalize_x() | input: %-3s | output: %-3s" "'$1'" "'$result'")"

	printf '%s' "$result"
}


semver_ranger()
{
	local range="$1"
	local major="$(semver_normalize_x "$2")"
	local minor="$(semver_normalize_x "$3")"
	local patch="$(semver_normalize_x "$4")"
	local result=''

	# echo "semver_ranger() | \$range: $range | \$major: $major | \$minor: $minor | \$patch: $patch" 1>&2

	if [[ "$range" = '~' ]]; then
		# Note: y is the actual value that matches [0-9]+ or [1-9][0-9]*
		# ~ = x.x.x
		# ~1 = 1.x.x
		# ~1.x = 1.x.x
		# ~1\.[0-9]+ = 1.y.x
		# ~1\.[0-9]+\.0 = 1.y.x
		# ~1\.[0-9]+\.[1-9][0-9]* = ~1.0.y

		#
		# If it is a number and not X or an empty string
		if [[ $major -ge 0 ]] && [[ "$major" != 'x' ]]; then
			if [[ $minor -ge 0 ]] && [[ "$major" != 'x' ]]; then
				if [[ $patch -gt 0 ]]; then
					: # Nada
				else # Patch is 0, 'x', or empty
					patch='x'
					# range=''
				fi
			else # Minor is 'x' or empty
				minor='x'
				patch='x'
				range=''
			fi
		else # Major is 'x' or empty
			major=0
			minor='x'
			patch='x'
			range=''
		fi
	elif [[ "$range" = '^' ]]; then
		# Note: y (minor) and x (patch) is the actual value that matches [0-9]+ or [1-9][0-9]*
		# ^[1+] = 1.x.x
		# ^[1+].[0-9x] = 1.x.x
		# ^[1+].[0-9x] = 1.x.x
		# ^[1+].[0-9x].[0-9x] = 1.x.x
		# ^0.[1+] = 0.1.x
		# ^0.[1+].[0-9x] = 0.1.x

		if [[ $major -gt 0 ]]; then
			minor='x'
			patch='x'
			range=''
		elif [[ $major -eq 0 ]] &&  [[ $major != 'x' ]]; then
			[[ $minor -gt 0 ]] && patch='x'
			range=''
		else # Major is x or empty
			major=0
			minor=0
			patch=0
			range=''
		fi

	fi
	result="${range}${major}.${minor}.${patch}"

	# echo "semver_ranger() | \$result: $result" 1>&2
	printf '%s' "$result"
}

###
# semver_compare_mmp_mod()
#
# SemVer MMP Comparision based on modifiable position information.
#
# @param	$range_one	Range donotion
# @param	$major_one	1st number major value
# @param	$minor_one	1st number minor value
# @param	$patch_one	1st number patch value
# @param	$major_two	2nd number major value
# @param	$minor_two	2nd number minor value
# @param	$patch_two	2nd number patch value
# @param	$mod_x    	Modifiable position indicator
# @param	$max_x    	Maximum value position indicator
# @param	$max_cap  	Maximum value of $max_x
# @return	digit	0: equality, 1: match, 2: mismatch
#
semver_compare_mmp_mod()
{
	local major_one="$1"; shift
	local minor_one="$1"; shift
	local patch_one="$1"; shift
	local major_two="$1"; shift
	local minor_two="$1"; shift
	local patch_two="$1"; shift
	local mod_x="$1"; shift
	local max_x="$1"; shift
	local -i max_cap=$1
	local result=2

	template_error 'semver_compare_mmp_mod() | mod_x: %-7s | max_x: %-6s | max_cap: %-3d' "$range_one" "$mod_x" "$max_x" $max_cap
	template_error 'semver_compare_mmp_mod() | major_one: %-3s | minor_one: %-3s | patch_one: %-3s' "$major_one" "$minor_one" "$patch_one"
	template_error 'semver_compare_mmp_mod() | major_two: %-3s | minor_two: %-3s | patch_two: %-3s' "$major_two" "$minor_two" "$patch_two"

	if [[ "$mod_x" = 'major' ]]; then
		if [[ $major_one -le $major_two ]] && [[ $major_two -lt $max_cap ]] || [[ "$major_one" = 'x' ]]; then
			result=0
		fi
	elif [[ "$mod_x" = 'minor' ]]; then
		if [[ $minor_one -le $minor_two ]] || [[ "$minor_one" = 'x' ]]; then
			let "max_cap = $major_one + 1"
			if [[ $major_one -eq $major_two ]]; then
				result=0
			fi
		fi
	elif [[ "$mod_x" = 'patch' ]]; then
		if [[ $patch_one -le $patch_one ]] || [[ "$patch_one" = 'x' ]]; then
			let "max_cap = $minor_one + 1"
			if [[ $minor_one -eq $minor_two ]]; then
				if [[ $major_one -eq $major_two ]]; then
					result=0
				fi
			fi
		fi
	elif [[ "$mod_x" = 'equal' ]]; then
		if [[ $major_one -eq $major_two ]] && [[ $minor_one -eq $minor_two ]] && [[ $patch_one -eq $patch_two ]]; then
			result=0
		fi
	fi
	template_error 'semver_compare_mmp_mod() | mod_x: %-7s | max_x: %-7s | max_cap: %-4d | result: %d' "$mod_x" "$max_x" $max_cap $result

	#
	# Test Equality
	#
	if [[ $result -eq 0 ]]; then
		if [[ $major_one -eq $major_two ]] && [[ $minor_one -eq $minor_two ]] || [[ $patch_one -eq $patch_two ]]; then
			result=0
		else
			result=1
		fi
	fi

	verimp_error "semver_compare_mmp_mod() | \$result: $result"

	return $result
}
#
# mod_x = if minor is >= 0 then minor
# mod_x = if patch is >= 0 then patch
#
# max_x = if mod_x is minor then major
# max_x = if mod_x is patch then minor
#
semver_compare_mmp()
{
	local -i int_parse
	local range_one="$1"
	local major_one="$2"
	local minor_one="$3"
	local patch_one="$4"
	local -i major_two="$5"
	local -i minor_two="$6"
	local -i patch_two="$7"
	local mod_x=''
	local max_x=''
	local -i max_cap=0
	local -i result_code=0

	if [[ $range_one = '~' ]]; then
		#
		# Examples:
		# ~1     allows for >= 1.0.0 < 2.0.0
		# ~1.2   allows for >= 1.2.0 < 1.3.0
		# ~1.2.3 allows for >= 1.2.3 < 1.3.0
		# ~0.1   allows for >= 0.1.0 < 0.2.0
		# ~0.1.2 allows for >= 0.1.2 < 0.2.0
		# ~0.0.1 allows for >= 0.0.1 < 0.1.0
		#
		#
		# mod_x = if minor is >= 0 then minor
		# mod_x = if patch is >= 0 then patch
		#
		# max_x = if mod_x is minor then major
		# max_x = if mod_x is patch then minor
		#
		max_x='major'
		mod_x='major'

		if [[ $minor_one -ge 0 ]] && [[ $minor_one != 'x' ]]; then
			mod_x='minor'
		fi

		if [[ $patch_one -ge 0 ]] && [[ $patch_one != 'x' ]]; then
			mod_x='patch'
		fi

		[[ "$mod_x" = 'minor' ]] && max_x='major'
		[[ "$mod_x" = 'patch' ]] && max_x='minor'

		[[ "$max_x" = 'major' ]] && let "max_cap = $major_one + 1"
		[[ "$max_x" = 'minor' ]] && let "max_cap = $minor_one + 1"
	elif [[ $range_one = '^' ]]; then
		#
		# Examples:
		# ^1     allows for >= 1.0.0 < 2.0.0
		# ^1.2   allows for >= 1.2.0 < 2.0.0
		# ^1.2.3 allows for >= 1.2.3 < 2.0.0
		# ^0.1.2 allows for >= 0.1.2 < 0.2.0
		#
		# mod_x = if major is = 0 then minor
		# mod_x = if mod_x = minor and minor is = 0 then patch
		# mod_x = if mod_x = patch and patch is = 0 then equal
		#
		mod_x='major'
		max_cap=0

		if [[ $major_one -eq 0 ]] && [[ $major_one != 'x' ]]; then
			mod_x='minor'
			let "max_cap = $minor_one + 1"
		fi

		if [[ "$mod_x" = 'minor' ]] && [[ $minor_one -eq 0 ]] && [[ $minor_one != 'x' ]]; then
			mod_x='patch'
		fi

		if [[ "$mod_x" = 'patch' ]] && [[ $patch_one -eq 0 ]] && [[ $minor_one != 'x' ]]; then
			mod_x='equal'
		fi

		[[ "$mod_x" = 'minor' ]] && max_x='major'
		[[ "$mod_x" = 'patch' ]] && max_x='minor'

		[[ "$max_x" = 'major' ]] && let "max_cap = $major_one + 1"
		[[ "$max_x" = 'minor' ]] && let "max_cap = $minor_one + 1"
		[[ "$max_x" = 'patch' ]] && let "max_cap = $patch_one + 1" # Reasonable?
	else
		if [[ "$major_one" = 'x' ]]; then
			mod_x='major'
			max_cap=0
		elif [[ "$minor_one" = 'x' ]]; then
			mod_x='minor'
			let "max_cap = $major_one + 1"
		elif [[ "$patch_one" = 'x' ]]; then
			mod_x='patch'
			let "max_cap = $minor_one + 1"
		else
			mod_x='equal'
			max_cap=0
		fi
	fi

	template_error 'semver_compare_mmp() | range_one: %-2s | mod_x: %-6s | max_x: %-6s | max_cap: %d' "$range_one" "$mod_x" "$max_x" $max_cap
	template_error 'semver_compare_mmp() | major_one: %-2s | minor_one: %-2s | patch_one: %-2s' $major_one $minor_one $patch_one
	template_error 'semver_compare_mmp() | major_two: %-2s | minor_two: %-2s | patch_two: %-2s' $major_two $minor_two $patch_two

	semver_compare_mmp_mod "$major_one" "$minor_one" "$patch_one" "$major_two" "$minor_two" "$patch_two" "$mod_x" "$max_x" $max_cap
	result_code=$?
	verimp_error "semver_compare_mmp() | \$result_code: $result_code"

	return $result_code
}

semver_compare_prerelease()
{
	local prtag_one="$1"
	local prtag_two="$2"

	local char_one
	local char_two
	local chunk_one
	local chunk_two

	verimp_error "semver_compare_prerelease() | \$prtag_one: $prtag_one | \$prtag_two: $prtag_two"

	until [[ ${#prtag_one} -eq 0 ]] && [[ ${#prtag_two} -eq 0 ]]; do
		:
		break
	done
}


semver_ranged_check()
{
	local -i exit_code=1
	local semver_raw="$1"
	local result=''

	# verimp_error "semver_ranged_check() | \$semver_raw: $semver_raw"

	  if [[ "${semver_raw:0:1}" = '~' ]]; then
		result='~'
		exit_code=0
	elif [[ "${semver_raw:0:1}" = '^' ]]; then
		result='^'
		exit_code=0
	elif [[ "$semver_raw" =~ [xX*] ]]; then
		result='x'
		exit_code=0
	elif [[ "$(semver_clean_re "$semver_raw")" =~ $ONE_OR_TWO_POSITION_VER_RE ]]; then
		result='t'
		exit_code=0
	fi

	echo "$result"
	return $exit_code
}


template_error()
{
	# echo "-- \$1: $1" 1>&2 # Debugging
	echo "  $(printf "$@")" 1>&2
}


verimp::compare()
{
	verimp_error 'verimp::compare() ...'

	local -i auto_match=1
	local -i comp_match=1
	local -i major_good=1
	local -i minor_good=1
	local -i patch_good=1
	local -i prtag_good=1
	local ver_one="$1"
	local ver_two="$2"

	local -i result_code=0
	local result_msg=''

	local ver_one_range
	local ver_one_ranged="$(semver_ranged_check "$ver_one")"
	local ver_one_major
	local ver_one_minor
	local ver_one_patch
	local ver_one_mmp
	local ver_one_prtag
	local ver_one_build

	local ver_two_clean="$(semver_clean_re "$2")"
	local ver_two_range
	local ver_two_ranged="$(semver_ranged_check "$ver_two")"
	local ver_two_major
	local ver_two_minor
	local ver_two_patch
	local ver_two_mmp
	local ver_two_prtag
	local ver_two_build

	# verimp_error "verimp::compare() | \$ver_two: '$ver_two' | \$ver_two_clean: '$ver_two_clean'"
	# verimp_error "verimp::compare() | \$ver_one_ranged: '$ver_one_ranged' | \$ver_two_ranged: '$ver_two_ranged'"


	if [[ "$ver_one_ranged" = '' ]] || [[ "$ver_two_ranged" != '' ]]; then
		# verimp_error "verimp::compare() | \$ver_two: $ver_two == ranged"
		ver_tmp="$ver_one"
		ver_one="$ver_two"
		ver_two="$ver_tmp"

		var_tmp="$ver_one_ranged"
		ver_one_ranged="$ver_two_ranged"
		ver_two_ranged="$ver_tmp"
	fi

	ver_one="$(verimp::normalize "$ver_one")"
	ver_two="$(verimp::normalize "$ver_two")"

	if [[ "$ver_one" =~ $SEMVER_NORMALIZE_RE ]]; then
		ver_one_range="${BASH_REMATCH[1]}"  # SemVer Version denotation (v or V) or Range indicator (~ or ^). Optional
		ver_one_major="${BASH_REMATCH[2]}"  # SemVer MMP Major Version. Mandatory
		ver_one_minor="${BASH_REMATCH[4]}"  # SemVer MMP Minor Version. Mandatory
		ver_one_patch="${BASH_REMATCH[6]}"  # SemVer MMP Patch Version. Mandatory
		ver_one_mmp="${BASH_REMATCH[2]}.${BASH_REMATCH[4]}.${BASH_REMATCH[6]}" # SemVer MMP Version. Mandatory
		ver_one_prtag="${BASH_REMATCH[8]}"  # SemVer 2.0.0 Prerelease Tag. Optional
		ver_one_build="${BASH_REMATCH[10]}" # SemVer 2.0.0 Build. Ignore when comparing. Optional
	fi
	template_error 'verimp::compare() | $ver_one | range: %1s | MMP: %-8s | prerelease: %-5s | build: %s' "$ver_one_range" "$ver_one_mmp" "$ver_one_prtag" "$ver_one_build"

	if [[ "$ver_two" =~ $SEMVER_NORMALIZE_RE ]]; then
		ver_two_range="${BASH_REMATCH[1]}"  # SemVer Version denotation (v or V) or Range indicator (~ or ^). Optional
		ver_two_major="${BASH_REMATCH[2]}"  # SemVer MMP Major Version. Mandatory
		ver_two_minor="${BASH_REMATCH[4]}"  # SemVer MMP Minor Version. Mandatory
		ver_two_patch="${BASH_REMATCH[6]}"  # SemVer MMP Patch Version. Mandatory
		ver_two_mmp="${BASH_REMATCH[2]}.${BASH_REMATCH[4]}.${BASH_REMATCH[6]}" # SemVer MMP Version. Mandatory
		ver_two_prtag="${BASH_REMATCH[8]}"  # SemVer 2.0.0 Prerelease Tag. Optional
		ver_two_build="${BASH_REMATCH[10]}" # SemVer 2.0.0 Build. Ignore when comparing. Optional
	fi
	template_error 'verimp::compare() | $ver_two | range: %1s | MMP: %-8s | prerelease: %-5s | build: %s' "$ver_two_range" "$ver_two_mmp" "$ver_two_prtag" "$ver_two_build"

	semver_compare_mmp "$ver_one_range" "$ver_one_major" "$ver_one_minor" "$ver_one_patch" "$ver_two_major" "$ver_two_minor" "$ver_two_patch"
	result_code=$?

	verimp_error "verimp::compare() | \$result_code: $result_code"

	if [[ $result_code -eq 0 ]]; then
		if [[ "x${ver_one_prtag}x" != 'xx' ]]; then
			semver_compare_prerelease "$ver_one_prtag" "$ver_two_prtag"
			result_code=$?
		fi
	elif [[ "x${ver_two_prtag}x" != 'xx' ]]; then
		result_code=1
	fi

	if [[ $result_code -eq 0 ]]; then
		echo "Good Match"
		exit 0
	else
		echo "Bad Match"
		exit 1
	fi

	#
	#
	# Caret Range:
	# Allows modifications of minor or patch digits to the right of the left most non-zero digit.
	# This is capped by the left most non-zero digit + 1.
	# Examples:
	# ^1     allows for >= 1.0.0 < 2.0.0
	# ^1.2   allows for >= 1.2.0 < 2.0.0
	# ^1.2.3 allows for >= 1.2.3 < 2.0.0
	# ^0.1.2 allows for >= 0.1.2 < 0.2.0
	#
	#
	# mod_x = if major is = 0 then minor
	# mod_x = if mod_x = minor and minor is = 0 then patch
	# mod_x = if mod_x = patch and patch is = 0 then no mod
	#
	#

	# if [[ $major_good -eq 0 ]] && [[ $minor_good -eq 0 ]] && [[ $patch_good -eq 0 ]]; then
	# 	verimp_error 'MMD Match!'

	# 	if [[ "x$ver_one_prtagx" != 'xx' ]] && [[ "x${ver_two_prtag}x" != 'xx' ]]; then
	# 		verimp_error 'Compare prerelease tags'
	# 	fi
	# else
	# 	verimp_error 'MMD Mismatch!'
	# fi

	if [[ "$ver_two" = "$ver_tmp" ]]; then
		ver_tmp="$ver_one"
		ver_one="$ver_two"
		ver_two="$ver_tmp"

		var_tmp="$ver_one_ranged"
		ver_one_ranged="$ver_two_ranged"
		ver_two_ranged="$ver_tmp"
	fi
}


verimp::normalize()
{
	local build
	local major
	local minor
	local patch
	local prtag
	local range=''
	local ranged=''
	local result=''
	local input="$1"

	if [[ "$input" =~ $SEMVER_NORMALIZE_RE ]]; then
		# echo "\${BASH_REMATCH[6]}: ${BASH_REMATCH[6]}" 1>&2
		# echo "\${BASH_REMATCH[7]}: ${BASH_REMATCH[7]}" 1>&2
		# echo "\${BASH_REMATCH[8]}: ${BASH_REMATCH[8]}" 1>&2
		# echo "\${BASH_REMATCH[9]}: ${BASH_REMATCH[9]}" 1>&2
		# echo "\${BASH_REMATCH[10]}: ${BASH_REMATCH[10]}" 1>&2
		range="${BASH_REMATCH[1]}"  # SemVer Version denotation (v or V) or Range indicator (~ or ^). Optional
		major="${BASH_REMATCH[2]}"  # SemVer MMP Major Version. Mandatory
		minor="${BASH_REMATCH[4]}"  # SemVer MMP Minor Version. Mandatory
		patch="${BASH_REMATCH[6]}"  # SemVer MMP Patch Version. Mandatory
		prtag="${BASH_REMATCH[8]}"  # SemVer 2.0.0 Prerelease Tag. Optional
		build="${BASH_REMATCH[10]}" # SemVer 2.0.0 Build. Ignore when comparing. Optional

		ranged="$(semver_ranger "$range" "$major" "$minor" "$patch")"
	fi

	# echo "verimp::normalize() INPUT | \$input: $input" 1>&2
	# echo "verimp::normalize() | \$major: $major | \$minor: $minor | \$patch: $patch | \$prtag: $prtag | \$build: $build" 1>&2
	
	result="${ranged}"
	[[ "x${prtag}x" != 'xx' ]] && result="${result}-${prtag}"
	[[ "x${build}x" != 'xx' ]] && result="${result}+${build}"

	# echo "verimp::normalize() | \$input: $input | \$ranged: $ranged | \$result: $result" 1>&2
	# verimp_error "$(printf 'verimp::normalize() | $input: %-8s | $ranged: %-8s | $result: %-8s\n' $input $ranged $result)"

	printf '%s' "$result"
}


verimp_error()
{
	echo "  $1" 1>&2
	if [[ "x$2" != "x" ]]; then
		exit $2
	fi
}

# echo "\$ver_one: $ver_one"
# if [[ "x${ver_one}x" != "xx" ]] && [[ "x${ver_two}x" != "xx" ]]; then

if [[ $# -eq 0 ]]; then
	echo "  Usage: $APP_FILE ~1.2.3 1.2" 1>&2
	exit 2
elif [[ $# -eq 2 ]]; then
	case "$1" in
		normalize)  echo "$(verimp::normalize "$2")"    ;;
		clean)      echo "$(semver_clean_re "$2")"      ;;
		*)          echo "$(verimp::compare "$1" "$2")" ;;
	esac
else
	case "$1" in
		-h | -help | --help)
			echo "  Usage: $APP_FILE ~1.2.3 1.2"
			exit 0
			;;
		*)
			echo "  Unknown command: $1"
			exit 2
			;;
	esac
fi
